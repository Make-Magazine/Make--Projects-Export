{"device":"Programming","url":"http:\/\/makeprojects.com\/Project\/InterActive+1\/2339\/1","guide":{"author":{"text":"Steven Robert Cypherd","userid":3592},"categories":["Programming","Circuits"],"conclusion":"<p>Fun way to get machines talking.<\/p>","difficulty":"Moderate","documents":[],"flags":[{"title":"User-Contributed Project","flagid":"GUIDE_USER_CONTRIBUTED","text":"This project guide is not managed by MAKE staff."}],"guideid":2339,"image":{"imageid":46087,"text":"http:\/\/guide-images.makeprojects.org\/igi\/5JhPJZjLLCxpxXdP"},"introduction":"<p>Life needs interaction to live. Machines need programs to interact with us. Programs need connectivity to grow more complicated. Serial communication is what machines use to grow. Serial communication is built into most processors. That is how you first program them and debug them. Serial connections let each part of a machine talk to the other parts to make the machine do more complicated tasks. People love interactive things. Serial connections let you make your machine interactive. I will show you an example of an interactive machine using my EasyLights and buttons.<\/p>\n\n<p>[&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;<a href=\"http:\/\/www.youtube.com\/embed\/lUXusYytw00%22\" rel=\"nofollow\" title=\"http:\/\/www.youtube.com\/embed\/lUXusYytw00&quot;\">http:\/\/www.youtube.com\/embed\/lUXusYytw00...<\/a> frameborder=&quot;0&quot; allowfullscreen<wbr \/>&gt;&lt;\/iframe&gt;]<\/p>\n\n<p>Getting my Basic Stamps to talk took a little programming. I wanted to run EasyLights in my Basic Stamp 2, sending the lights byte to the Basic Stamp 1 and reading buttons back. I had trouble getting messages between the Basic Stamp 2 (BS2) and the Basic Stamp 1 (BS1). The BS2 is about four times faster than the BS1. The BS1 locks up waiting for the BS2 message. The BS1 cannot see the BS2 message in the 200 millisecond (ms) window it has to check for a message. This is exactly why there are so many flow control lines left in standard serial connectors. Slower machines can\u2019t see faster ones. I needed flow control, but I didn\u2019t want to use another port for it. I have an electronics background so I looked at the Rx and Tx as ports, not just as serial connections.<\/p>\n\n<p>Steve\u2019s Flow Control uses the Tx port as flow control. You hold your Tx port high with a resistor of 47K to V<sub>DD<\/sub> and in your code. You monitor your Rx port to detect when someone lowers its Tx port. When you want to send a message you bring your Tx port low, wait until the receiver lowers its Tx port and then you send your message. The receiver should stay in a tight loop waiting for the message. After the message both systems raise their Tx ports high and go back to waiting.<\/p>\n\n<p>For the BS1 and slower systems I lower my (Master) BS2\u2019s Tx port and pause about 80 ms, and then I transmit my message. The BS1 looks for a low on its Rx port and pauses 1ms and then opens SerIn for a two-byte message. The first byte is the Address and the second byte is the Lights. If the Address is not correct the BS1 skips the message and goes back to waiting. The BS1 is too slow for full handshaking. It works perfectly with correct timing.<\/p>\n\n<p>I can only send one message to the BS1 in every ten loops of my BS2\u2019s code. I am running EasyLights in my BS2 and sending the lights byte to the BS1 that only has doLights and checkLights and a message loop. See my EasyLights article.<\/p>\n\n<p>I could not get the BS1 to send a correct two-byte message. The first byte is garbled and I do not know why. The BS1 can\u2019t use my standard two-byte messaging (Address, Data) so I am using a separate serial channel to handle this type of slave. The BS1 lowers its Tx port and waits until the Master lowers its slave Tx port and then the BS1 sends a one-byte message containing the button flags to the Master. They both raise their Tx ports high and go back to waiting.<\/p>\n\n<p>Working with the BS1 I decided to make them polled slaves. I simply keep them alive by constantly sending them messages. They do all of their work inside their message loop. There is no room for much else. They just sit there and wait for a message so their buttons and lights are, in effect, dead. Polling them keeps their buttons and lights alive.<\/p>\n\n<p>As I get things done I will upload another part to this interactive article.<\/p>\n\n<p>See articles and source code on <a href=\"http:\/\/letsmakerobots.com\" rel=\"nofollow\">http:\/\/letsmakerobots.com<\/a> and <a href=\"http:\/\/instructables.com\" rel=\"nofollow\">http:\/\/instructables.com<\/a>.<\/p>","introduction_rendered":"<p>Life needs interaction to live. Machines need programs to interact with us. Programs need connectivity to grow more complicated. Serial communication is what machines use to grow. Serial communication is built into most processors. That is how you first program them and debug them. Serial connections let each part of a machine talk to the other parts to make the machine do more complicated tasks. People love interactive things. Serial connections let you make your machine interactive. I will show you an example of an interactive machine using my EasyLights and buttons.<\/p>\n\n<p>[&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;<a href=\"http:\/\/www.youtube.com\/embed\/lUXusYytw00%22\" rel=\"nofollow\" title=\"http:\/\/www.youtube.com\/embed\/lUXusYytw00&quot;\">http:\/\/www.youtube.com\/embed\/lUXusYytw00...<\/a> frameborder=&quot;0&quot; allowfullscreen<wbr \/>&gt;&lt;\/iframe&gt;]<\/p>\n\n<p>Getting my Basic Stamps to talk took a little programming. I wanted to run EasyLights in my Basic Stamp 2, sending the lights byte to the Basic Stamp 1 and reading buttons back. I had trouble getting messages between the Basic Stamp 2 (BS2) and the Basic Stamp 1 (BS1). The BS2 is about four times faster than the BS1. The BS1 locks up waiting for the BS2 message. The BS1 cannot see the BS2 message in the 200 millisecond (ms) window it has to check for a message. This is exactly why there are so many flow control lines left in standard serial connectors. Slower machines can\u2019t see faster ones. I needed flow control, but I didn\u2019t want to use another port for it. I have an electronics background so I looked at the Rx and Tx as ports, not just as serial connections.<\/p>\n\n<p>Steve\u2019s Flow Control uses the Tx port as flow control. You hold your Tx port high with a resistor of 47K to V<sub>DD<\/sub> and in your code. You monitor your Rx port to detect when someone lowers its Tx port. When you want to send a message you bring your Tx port low, wait until the receiver lowers its Tx port and then you send your message. The receiver should stay in a tight loop waiting for the message. After the message both systems raise their Tx ports high and go back to waiting.<\/p>\n\n<p>For the BS1 and slower systems I lower my (Master) BS2\u2019s Tx port and pause about 80 ms, and then I transmit my message. The BS1 looks for a low on its Rx port and pauses 1ms and then opens SerIn for a two-byte message. The first byte is the Address and the second byte is the Lights. If the Address is not correct the BS1 skips the message and goes back to waiting. The BS1 is too slow for full handshaking. It works perfectly with correct timing.<\/p>\n\n<p>I can only send one message to the BS1 in every ten loops of my BS2\u2019s code. I am running EasyLights in my BS2 and sending the lights byte to the BS1 that only has doLights and checkLights and a message loop. See my EasyLights article.<\/p>\n\n<p>I could not get the BS1 to send a correct two-byte message. The first byte is garbled and I do not know why. The BS1 can\u2019t use my standard two-byte messaging (Address, Data) so I am using a separate serial channel to handle this type of slave. The BS1 lowers its Tx port and waits until the Master lowers its slave Tx port and then the BS1 sends a one-byte message containing the button flags to the Master. They both raise their Tx ports high and go back to waiting.<\/p>\n\n<p>Working with the BS1 I decided to make them polled slaves. I simply keep them alive by constantly sending them messages. They do all of their work inside their message loop. There is no room for much else. They just sit there and wait for a message so their buttons and lights are, in effect, dead. Polling them keeps their buttons and lights alive.<\/p>\n\n<p>As I get things done I will upload another part to this interactive article.<\/p>\n\n<p>See articles and source code on <a href=\"http:\/\/letsmakerobots.com\" rel=\"nofollow\">http:\/\/letsmakerobots.com<\/a> and <a href=\"http:\/\/instructables.com\" rel=\"nofollow\">http:\/\/instructables.com<\/a>.<\/p>","locale":"en","parts":[],"prereqs":[],"steps":[{"title":"","lines":[{"text":"No circuit.","text_raw":"No circuit.","bullet":"black","level":0}],"object":null,"images":[{"imageid":46087,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/5JhPJZjLLCxpxXdP"},{"imageid":46088,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/GNlM53wTYETE4wlA"},{"imageid":46089,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/QW1kyMA53vZROwTR"}],"number":1},{"title":"","lines":[{"text":"The Basic Stamp 2","text_raw":"The Basic Stamp 2","bullet":"black","level":0},{"text":"More documents","text_raw":"More documents","bullet":"black","level":0}],"object":null,"images":[{"imageid":46086,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/gLFIX5vADKgu2oPV"},{"imageid":46096,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/qTmIQYWESPYnMpos"},{"imageid":46097,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/EPOiBB5uSOnLTGmO"}],"number":2},{"title":"","lines":[{"text":"Last one","text_raw":"Last one","bullet":"black","level":0}],"object":null,"images":[{"imageid":46095,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/KccNALSKEm46NALU"}],"number":3}],"subject":"","summary":"Programming two Basic Stamps to talk to each other.","time_required":"1 hour","title":"InterActive 1","tools":[],"type":"project"},"guideid":"2339"}