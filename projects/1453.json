{"device":"Remote Control","url":"http:\/\/makeprojects.com\/Project\/Hacking+R-C+Power+Outlets\/1453\/1","guide":{"author":{"text":"Andrew Wedgbury","userid":8296},"categories":["Remote Control"],"conclusion":"<p><strong>This project first appeared in <a href=\"http:\/\/makezine.com\/22\">MAKE Volume 22<\/a>, page 70.<\/strong><\/p>","difficulty":"Moderate","documents":[],"flags":[{"title":"From MAKE Magazine","flagid":"FROM_MAKE","text":"This project first appeared on the pages of MAKE magazine."}],"guideid":1453,"image":{"imageid":30229,"text":"http:\/\/guide-images.makeprojects.org\/igi\/pS2QpuJKuZuB6N1r"},"introduction":"<p>Switching plug-in appliances from your computer or microcontroller isn\u2019t difficult in theory, but doing it without turning your home into a potential deathtrap can be tricky. The safer way is to rely on remote control rather than wiring directly.<\/p>","introduction_rendered":"<p>Switching plug-in appliances from your computer or microcontroller isn\u2019t difficult in theory, but doing it without turning your home into a potential deathtrap can be tricky. The safer way is to rely on remote control rather than wiring directly.<\/p><div class=\"parts\"><strong>Relevant parts<\/strong><ul><li><a href=\"http:\/\/makeprojects.com\/Item\/R_C_power_outlet_system\">R\/C power outlet system<\/a><\/li><li><a href=\"http:\/\/makeprojects.com\/Item\/USB_Bit_Whacker_microcontroller_board\">USB Bit Whacker microcontroller board<\/a><\/li><li><a href=\"http:\/\/www.radioshack.com\/product\/index.jsp?productId=2049745\">Hookup wire<\/a><\/li><\/ul><\/div><div class=\"tools\"><strong>Tools<\/strong><ul><li><a href=\"http:\/\/makeprojects.com\/Item\/Computer\">Computer<\/a><\/li><li><a href=\"http:\/\/makeprojects.com\/Item\/Screwdriver\">Screwdriver<\/a><\/li><li><a href=\"http:\/\/www.radioshack.com\/product\/index.jsp?productId=3086619\">Soldering iron<\/a><\/li><li><a href=\"http:\/\/www.radioshack.com\/product\/index.jsp?productId=3932543\">Wire cutter\/stripper<\/a><\/li><\/ul><\/div>","locale":"en","parts":[{"text":"R\/C power outlet system","notes":"I used a Maplin N19GN, which works for mains in the United Kingdom, and my code is tailored to its wireless protocol. You\u2019ll want to use a system with the appropriate power connectors and ratings for your country.","url":"http:\/\/makeprojects.com\/Item\/R_C_power_outlet_system","thumbnail":""},{"text":"USB Bit Whacker microcontroller board","notes":"part #DEV-00762 from SparkFun Electronics (http:\/\/sparkfun.com)","url":"http:\/\/makeprojects.com\/Item\/USB_Bit_Whacker_microcontroller_board","thumbnail":""},{"text":"Hookup wire","notes":"","url":"http:\/\/www.radioshack.com\/product\/index.jsp?productId=2049745","thumbnail":""}],"prereqs":[],"steps":[{"title":"Hack your R\/C power outlet.","lines":[{"text":"Here\u2019s how I reverse-engineered and modified an inexpensive R\/C power outlet switching system so that it can control a practically unlimited number of AC-powered devices wirelessly from a computer. This flexible setup lets me switch appliances on and off via the internet and run programs that switch them automatically at certain times of the day.","text_raw":"Here\u2019s how I reverse-engineered and modified an inexpensive R\/C power outlet switching system so that it can control a practically unlimited number of AC-powered devices wirelessly from a computer. This flexible setup lets me switch appliances on and off via the internet and run programs that switch them automatically at certain times of the day.","bullet":"black","level":0},{"text":"I had the idea for this project after buying a set of remote controlled power outlets from my local electronics store. Quite a few of these systems are available; they use radio frequencies, so you don\u2019t need line-of-sight like you would with IR remote systems, and some are even housed in waterproof casings for installing outside. They all work on the same principle: you plug an appliance through the R\/C outlet unit into a regular power outlet, and then the remote lets you switch power to the appliance on and off.","text_raw":"I had the idea for this project after buying a set of remote controlled power outlets from my local electronics store. Quite a few of these systems are available; they use radio frequencies, so you don\u2019t need line-of-sight like you would with IR remote systems, and some are even housed in waterproof casings for installing outside. They all work on the same principle: you plug an appliance through the R\/C outlet unit into a regular power outlet, and then the remote lets you switch power to the appliance on and off.","bullet":"black","level":0},{"text":"The set I bought has 3 outlet units and a remote control with On\/Off buttons for each outlet, plus a master button pair that switches all outlets at once. You assign the buttons to the remote by pressing a Learn button on the outlet and then pressing the On button on the remote that you want to associate with it. If you wish, you can train multiple outlets to respond to the same button pair.","text_raw":"The set I bought has 3 outlet units and a remote control with On\/Off buttons for each outlet, plus a master button pair that switches all outlets at once. You assign the buttons to the remote by pressing a Learn button on the outlet and then pressing the On button on the remote that you want to associate with it. If you wish, you can train multiple outlets to respond to the same button pair.","bullet":"black","level":0},{"text":"I was impressed by this system and was keen to expand it to control more than just 3 appliances. The instructions didn\u2019t mention whether multiple sets would work without interference, but I noticed that if you left the remote\u2019s battery disconnected for a while, you had to retrain all the outlet units.","text_raw":"I was impressed by this system and was keen to expand it to control more than just 3 appliances. The instructions didn\u2019t mention whether multiple sets would work without interference, but I noticed that if you left the remote\u2019s battery disconnected for a while, you had to retrain all the outlet units.","bullet":"black","level":0},{"text":"The only explanation I could think of for this was that the remote generates a new unique identifier when it powers up, which the outlet units store during the learning process. If so, this was a good sign, as it suggested that you could co-locate 2 or more sets (and other similar devices), provided that their remotes used different identifiers.","text_raw":"The only explanation I could think of for this was that the remote generates a new unique identifier when it powers up, which the outlet units store during the learning process. If so, this was a good sign, as it suggested that you could co-locate 2 or more sets (and other similar devices), provided that their remotes used different identifiers.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30229,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/pS2QpuJKuZuB6N1r"},{"imageid":30234,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/BSSBujwcwSRTg4Xn"}],"number":1},{"title":"","lines":[{"text":"So far so good, except that you\u2019d still need a separate remote for every 3 units, which would get out of hand if you wanted to control a lot of devices. To find better alternatives, I opened up the remote control unit. The main circuit board housed button pads, an Elan EM78P153SNJ microcontroller (MCU), a 5V regulator, and an LED; underneath it sat another board with the radio transmitter circuit and antenna.","text_raw":"So far so good, except that you\u2019d still need a separate remote for every 3 units, which would get out of hand if you wanted to control a lot of devices. To find better alternatives, I opened up the remote control unit. The main circuit board housed button pads, an Elan EM78P153SNJ microcontroller (MCU), a 5V regulator, and an LED; underneath it sat another board with the radio transmitter circuit and antenna.","bullet":"black","level":0},{"text":"There was enough room inside the remote to hold a small microcontroller board. A microcontroller wired to the button contacts could then simulate button presses on the remote, and you could plug its USB interface into a computer to pass switching control over to the computer.","text_raw":"There was enough room inside the remote to hold a small microcontroller board. A microcontroller wired to the button contacts could then simulate button presses on the remote, and you could plug its USB interface into a computer to pass switching control over to the computer.","bullet":"black","level":0},{"text":"Also, the main board had unused pads for an extra pair of buttons, so it looked like you could easily wire the remote to control 4 devices instead of 3. By wiring  into the remote like this, you don\u2019t need to modify the power outlet units at all; they remain safely intact with all their approvals (FCC, CE, UL, etc.).","text_raw":"Also, the main board had unused pads for an extra pair of buttons, so it looked like you could easily wire the remote to control 4 devices instead of 3. By wiring  into the remote like this, you don\u2019t need to modify the power outlet units at all; they remain safely intact with all their approvals (FCC, CE, UL, etc.).","bullet":"black","level":0},{"text":"But 4 devices per remote still isn\u2019t much, so I decided instead to try and intercept the data signals being sent from the remote\u2019s microcontroller to the radio transmitter circuit on the board underneath. If I could decode these signals, then I could also generate my own signals and control lots more devices, if the protocol allowed it.","text_raw":"But 4 devices per remote still isn\u2019t much, so I decided instead to try and intercept the data signals being sent from the remote\u2019s microcontroller to the radio transmitter circuit on the board underneath. If I could decode these signals, then I could also generate my own signals and control lots more devices, if the protocol allowed it.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30232,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/lL1pFMAQXSGN6PZv"},{"imageid":30230,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/ZqCMxUmDGBi1wo6Z"}],"number":2},{"title":"Splice in.","lines":[{"text":"To decode and hopefully generate R\/C signals, I used a USB Bit Whacker microcontroller from SparkFun Electronics. The remote\u2019s main board and the Bit Whacker both use 5V DC, and I knew I would be running the Bit Whacker off USB power, so I connected power and ground between the Bit Whacker and the remote board, on the 5V side of its voltage regulator. This eliminated the need for the battery, by powering the remote over USB, and it also made room for the Bit Whacker, which fit neatly in the battery\u2019s place.","text_raw":"To decode and hopefully generate R\/C signals, I used a USB Bit Whacker microcontroller from SparkFun Electronics. The remote\u2019s main board and the Bit Whacker both use 5V DC, and I knew I would be running the Bit Whacker off USB power, so I connected power and ground between the Bit Whacker and the remote board, on the 5V side of its voltage regulator. This eliminated the need for the battery, by powering the remote over USB, and it also made room for the Bit Whacker, which fit neatly in the battery\u2019s place.","bullet":"black","level":0},{"text":"I needed to make 2 more connections to splice the Bit Whacker between the main board and the transmitter so that it could intercept the signal. The yellow dotted line in the picture shows this data connection.","text_raw":"I needed to make 2 more connections to splice the Bit Whacker between the main board and the transmitter so that it could intercept the signal. The yellow dotted line in the picture shows this data connection.","bullet":"black","level":0},{"text":"To intercept this connection, I simply severed a wire on the underside of the main board, soldered leads to each endpoint, and ran them to pins B0 and B1 on the Bit Whacker. The pink wire feeds the remote\u2019s original button-press signals into the Bit Whacker\u2019s Pin B1, and the yellow wire from Pin B0 sends signals generated by the Bit Whacker to the transmitter circuit board.","text_raw":"To intercept this connection, I simply severed a wire on the underside of the main board, soldered leads to each endpoint, and ran them to pins B0 and B1 on the Bit Whacker. The pink wire feeds the remote\u2019s original button-press signals into the Bit Whacker\u2019s Pin B1, and the yellow wire from Pin B0 sends signals generated by the Bit Whacker to the transmitter circuit board.","bullet":"black","level":0},{"text":"I found that the Bit Whacker board could be glued inside the lid at the rear of the remote, where I cut out a rectangular hole for the USB port. With this modification, removing the battery compartment cover reveals the Bit Whacker (red board in pictures).","text_raw":"I found that the Bit Whacker board could be glued inside the lid at the rear of the remote, where I cut out a rectangular hole for the USB port. With this modification, removing the battery compartment cover reveals the Bit Whacker (red board in pictures).","bullet":"black","level":0},{"text":"Once the modifications to the remote were complete, I turned to the software side of things. I would use the Bit Whacker to determine what the signals sent to the radio transmitter looked like, and then hopefully generate my own working signals by following the same protocol.","text_raw":"Once the modifications to the remote were complete, I turned to the software side of things. I would use the Bit Whacker to determine what the signals sent to the radio transmitter looked like, and then hopefully generate my own working signals by following the same protocol.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30240,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/6jmCVXxSTDDwDUR2"},{"imageid":30231,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/QCxFTT1ZnpZoFDZ1"},{"imageid":30235,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/UIBETImalN4FitJ6"}],"number":3},{"title":"Crack the code.","lines":[{"text":"The Bit Whacker is a fantastically simple but versatile little board, consisting of a PIC18F2553 microcontroller plus a few supporting components: an oscillator, reset and program buttons, status LEDs, and a USB socket. It comes already programmed with firmware based on the Microchip USB framework that makes the device appear as a serial port (the firmware can also be updated over USB if desired).","text_raw":"The Bit Whacker is a fantastically simple but versatile little board, consisting of a PIC18F2553 microcontroller plus a few supporting components: an oscillator, reset and program buttons, status LEDs, and a USB socket. It comes already programmed with firmware based on the Microchip USB framework that makes the device appear as a serial port (the firmware can also be updated over USB if desired).","bullet":"black","level":0},{"text":"You can control it by sending text-based commands using a terminal program such as Hyperterminal, or by writing your own program that talks to the serial port. A full set of commands is available to control the port pins and perform various other functions.","text_raw":"You can control it by sending text-based commands using a terminal program such as Hyperterminal, or by writing your own program that talks to the serial port. A full set of commands is available to control the port pins and perform various other functions.","bullet":"black","level":0},{"text":"It was time to apply this functionality to eavesdrop on the remote. I considered sampling the signal to the remote\u2019s transmitter at regular intervals, but the PIC\u2019s memory was too small to store very many samples. Because the signal was probably digital (On or Off), I figured it would be more efficient to simply record the times between its state changes.","text_raw":"It was time to apply this functionality to eavesdrop on the remote. I considered sampling the signal to the remote\u2019s transmitter at regular intervals, but the PIC\u2019s memory was too small to store very many samples. Because the signal was probably digital (On or Off), I figured it would be more efficient to simply record the times between its state changes.","bullet":"black","level":0},{"text":"To do this, I needed to make some modifications to the Bit Whacker\u2019s firmware, adding a new command that uses one of the PIC\u2019s timers to count the clock ticks, then write out and reset the value whenever input pin B1 changes. You can download this code <a href=\"http:\/\/cdn.makezine.com\/make\/22\/UBW_D_143_remote_outlet_mods_v1.zip\">here<\/a>.","text_raw":"To do this, I needed to make some modifications to the Bit Whacker\u2019s firmware, adding a new command that uses one of the PIC\u2019s timers to count the clock ticks, then write out and reset the value whenever input pin B1 changes. You can download this code [http:\/\/cdn.makezine.com\/make\/22\/UBW_D_143_remote_outlet_mods_v1.zip|here].","bullet":"black","level":0},{"text":"The Bit Whacker appears as a USB serial port. I connected to it with a terminal window, experimented with the remote buttons, and then analyzed the data that the Bit Whacker was putting out.","text_raw":"The Bit Whacker appears as a USB serial port. I connected to it with a terminal window, experimented with the remote buttons, and then analyzed the data that the Bit Whacker was putting out.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30239,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/BgRmwA4qREtcKnIh"}],"number":4},{"title":"","lines":[{"text":"I found that each button press generates a long start pulse followed by a fixed pattern of 25 pulses, which together act as a \u201cget ready to receive\u201d signal, followed by a variable pattern of 64 pulses encoding 8 bytes of data. The start pulse is 3.6ms, and all subsequent pulses are 0.5ms. The gaps between pulses are either long (0.8ms), representing binary 0, or short (0.5ms), representing binary 1.","text_raw":"I found that each button press generates a long start pulse followed by a fixed pattern of 25 pulses, which together act as a \u201cget ready to receive\u201d signal, followed by a variable pattern of 64 pulses encoding 8 bytes of data. The start pulse is 3.6ms, and all subsequent pulses are 0.5ms. The gaps between pulses are either long (0.8ms), representing binary 0, or short (0.5ms), representing binary 1.","bullet":"black","level":0},{"text":"The way that the outlet unit\u2019s switching commands were encoded in these 8 bytes of data was not as simple as I had anticipated. Through further detective work, I found that the 8 bytes are decoded by the outlets into messages 4 bytes long.","text_raw":"The way that the outlet unit\u2019s switching commands were encoded in these 8 bytes of data was not as simple as I had anticipated. Through further detective work, I found that the 8 bytes are decoded by the outlets into messages 4 bytes long.","bullet":"black","level":0},{"text":"Two of the 4 decoded bytes represent an identifier or the remote, which it picks randomly when it powers up and sends with each command (as I had guessed). Because this is a 16-bit value, it potentially allows for addressing up to 65,536 sets of outlet units. A third decoded byte conveys the power-switching command itself.","text_raw":"Two of the 4 decoded bytes represent an identifier or the remote, which it picks randomly when it powers up and sends with each command (as I had guessed). Because this is a 16-bit value, it potentially allows for addressing up to 65,536 sets of outlet units. A third decoded byte conveys the power-switching command itself.","bullet":"black","level":0},{"text":"The remaining decoded byte is a counter value that increments with each command sent. This counter value obfuscated my code-breaking efforts, since it results in different data being sent every time the same button is pressed. But the outlet units don\u2019t actually check the counter value, and they respond to data encoded using the same counter value repeatedly.","text_raw":"The remaining decoded byte is a counter value that increments with each command sent. This counter value obfuscated my code-breaking efforts, since it results in different data being sent every time the same button is pressed. But the outlet units don\u2019t actually check the counter value, and they respond to data encoded using the same counter value repeatedly.","bullet":"black","level":0},{"text":"The decoding scheme for the transmission was fairly simple. If you designate the 8-byte transmission as composed of bytes X1 to X4 followed by  Y1 to Y4, you derive the decoded bytes Z1 to Z4 by subtracting each byte pairwise (shown in picture 2). Decoded byte Z1 is the counter, byte Z3 is the command, and bytes Z2 and Z4 make up the 2-byte identifier for the remote.","text_raw":"The decoding scheme for the transmission was fairly simple. If you designate the 8-byte transmission as composed of bytes X1 to X4 followed by  Y1 to Y4, you derive the decoded bytes Z1 to Z4 by subtracting each byte pairwise (shown in picture 2). Decoded byte Z1 is the counter, byte Z3 is the command, and bytes Z2 and Z4 make up the 2-byte identifier for the remote.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30241,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/AGFPFlYVtxJTos3g"},{"imageid":30242,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/aZlhUkK5BPlQALqB"}],"number":5},{"title":"","lines":[{"text":"When I started programming the Bit Whacker to work the other way \u2014 encoding commands for transmission to the outlets \u2014 I found it was more complicated than simply picking byte values for X and Y that generated the right Zs. Instead, various relationships between the absolute values of the 8 encoded bytes had to be present in order for the outlet unit to accept the commands.","text_raw":"When I started programming the Bit Whacker to work the other way \u2014 encoding commands for transmission to the outlets \u2014 I found it was more complicated than simply picking byte values for X and Y that generated the right Zs. Instead, various relationships between the absolute values of the 8 encoded bytes had to be present in order for the outlet unit to accept the commands.","bullet":"black","level":0},{"text":"There\u2019s no serious encryption going on here, but all the internal arithmetic relationships act as a parity check, making it extremely unlikely for the outlet units to be triggered by random noise or interference from other systems.","text_raw":"There\u2019s no serious encryption going on here, but all the internal arithmetic relationships act as a parity check, making it extremely unlikely for the outlet units to be triggered by random noise or interference from other systems.","bullet":"black","level":0},{"text":"The calculations below show how this encoding works. Note that all encoding and decoding operations are single byte (mod 256), which means that the value wraps around to 0 when incremented past 255 (see picture 1).","text_raw":"The calculations below show how this encoding works. Note that all encoding and decoding operations are single byte (mod 256), which means that the value wraps around to 0 when incremented past 255 (see picture 1).","bullet":"black","level":0},{"text":"The decoded command byte, Z3, has several possible values. Most of them correspond to buttons on the remote control, but through testing I also found several other command values which the outlet units respond to. The most notable is 0x64, which appears to affect only units that are currently off, switching them on for a brief moment and then off again.","text_raw":"The decoded command byte, Z3, has several possible values. Most of them correspond to buttons on the remote control, but through testing I also found several other command values which the outlet units respond to. The most notable is 0x64, which appears to affect only units that are currently off, switching them on for a brief moment and then off again.","bullet":"black","level":0},{"text":"Photo 2 lists all the commands that I was able to determine, as single byte values in 2-digit hexadecimal notation. There are commands to independently switch up to 4 units per remote, so given the number of possible identifiers, this allows 262,144 individual outlets to be controlled!","text_raw":"Photo 2 lists all the commands that I was able to determine, as single byte values in 2-digit hexadecimal notation. There are commands to independently switch up to 4 units per remote, so given the number of possible identifiers, this allows 262,144 individual outlets to be controlled!","bullet":"black","level":0},{"text":"This information enabled me to encode and inject my own data to be transmitted to the outlet units. To accomplish this, I made some further modifications to the Bit Whacker firmware, so that it would generate waveforms comparable with those produced by the remote.","text_raw":"This information enabled me to encode and inject my own data to be transmitted to the outlet units. To accomplish this, I made some further modifications to the Bit Whacker firmware, so that it would generate waveforms comparable with those produced by the remote.","bullet":"black","level":0}],"object":null,"images":[{"imageid":30243,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/a6SVMnnlUTFvlWJ2"},{"imageid":30244,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/Xm4r1I5RgwELYeNK"}],"number":6},{"title":"Customize the remote outlet control application.","lines":[{"text":"The final part of the project was to write a computer application in C++ to control the units, as it wasn\u2019t very convenient having to enter commands into a serial console.","text_raw":"The final part of the project was to write a computer application in C++ to control the units, as it wasn\u2019t very convenient having to enter commands into a serial console.","bullet":"black","level":0},{"text":"While developing my first version of the program, I found that if you called it twice in rapid succession, say, to switch multiple devices at the same time, the opening and closing of the USB port would sometimes fail. So I split the program into 2 separate processes: a server, which runs all the time in the background, holding the serial port open and managing the flow of commands; and a command-line client, which sends commands to the server.","text_raw":"While developing my first version of the program, I found that if you called it twice in rapid succession, say, to switch multiple devices at the same time, the opening and closing of the USB port would sometimes fail. So I split the program into 2 separate processes: a server, which runs all the time in the background, holding the serial port open and managing the flow of commands; and a command-line client, which sends commands to the server.","bullet":"black","level":0},{"text":"I used TCP\/IP sockets as the communication method, which lets the server and client run on different machines if desired.","text_raw":"I used TCP\/IP sockets as the communication method, which lets the server and client run on different machines if desired.","bullet":"black","level":0}],"object":null,"images":[],"number":7},{"title":"","lines":[{"text":"You can download the application, Remote Outlet Control <a href=\"http:\/\/cdn.makezine.com\/make\/22\/outlet_v1.0.zip\">here<\/a>. The screen capture shows the application running on Windows. The electrical socket icon in the system tray indicates that the server process is running.","text_raw":"You can download the application, Remote Outlet Control [http:\/\/cdn.makezine.com\/make\/22\/outlet_v1.0.zip|here]. The screen capture shows the application running on Windows. The electrical socket icon in the system tray indicates that the server process is running.","bullet":"black","level":0},{"text":"To create the toolbar at the bottom, I selected New Toolbar from the regular toolbar\u2019s right-click menu. Then I created the Lamp shortcuts on the desktop and the Fan shortcuts on the toolbar and entered the command-line program name, outletctl, and its required arguments (<tt>device_ID [0-65535], button [a, b, c, d, all]<\/tt>, and <tt>state [on, off]<\/tt>) in the Target box. I also chose an appropriate icon using the Change Icon button. (I created all of the application\u2019s icons using Inkscape.)","text_raw":"To create the toolbar at the bottom, I selected New Toolbar from the regular toolbar\u2019s right-click menu. Then I created the Lamp shortcuts on the desktop and the Fan shortcuts on the toolbar and entered the command-line program name, outletctl, and its required arguments (``device_ID [0-65535], button [a, b, c, d, all]``, and ``state [on, off]``) in the Target box. I also chose an appropriate icon using the Change Icon button. (I created all of the application\u2019s icons using Inkscape.)","bullet":"black","level":0},{"text":"For the scheduled tasks shown, I dragged the desired shortcuts into the Scheduled Tasks window, under Control Panel\/Administrative Tools. This pane supports numerous scheduling options, but if it isn\u2019t flexible enough, you can also call the program from a batch file or scripting language of your choice (I\u2019d recommend Perl).","text_raw":"For the scheduled tasks shown, I dragged the desired shortcuts into the Scheduled Tasks window, under Control Panel\/Administrative Tools. This pane supports numerous scheduling options, but if it isn\u2019t flexible enough, you can also call the program from a batch file or scripting language of your choice (I\u2019d recommend Perl).","bullet":"black","level":0},{"text":"There\u2019s a great deal of potential in these off- the-shelf remote outlet systems; their availability and relatively low cost makes them ideal for any electronic projects that need to switch plug-in appliances.","text_raw":"There\u2019s a great deal of potential in these off- the-shelf remote outlet systems; their availability and relatively low cost makes them ideal for any electronic projects that need to switch plug-in appliances.","bullet":"black","level":0},{"text":"This project highlights just one way of using them, and I\u2019ve tried to keep my modifications as general as possible so they\u2019re useful to others. Hopefully I\u2019ve shown how easy it can be to interface with these systems, and how, by understanding a bit about how they work, you can make them work the way you want them to!","text_raw":"This project highlights just one way of using them, and I\u2019ve tried to keep my modifications as general as possible so they\u2019re useful to others. Hopefully I\u2019ve shown how easy it can be to interface with these systems, and how, by understanding a bit about how they work, you can make them work the way you want them to!","bullet":"black","level":0}],"object":null,"images":[{"imageid":30237,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/fU3r4tNEXitl36EE"}],"number":8}],"subject":"","summary":"Inexpensive wireless home automation.","time_required":"A weekend","title":"Hacking R\/C Power Outlets","tools":[{"text":"Computer","notes":"","url":"http:\/\/makeprojects.com\/Item\/Computer","thumbnail":""},{"text":"Screwdriver","notes":"","url":"http:\/\/makeprojects.com\/Item\/Screwdriver","thumbnail":""},{"text":"Soldering iron","notes":"","url":"http:\/\/www.radioshack.com\/product\/index.jsp?productId=3086619","thumbnail":""},{"text":"Wire cutter\/stripper","notes":"","url":"http:\/\/www.radioshack.com\/product\/index.jsp?productId=3932543","thumbnail":""}],"type":"project"},"guideid":"1453"}