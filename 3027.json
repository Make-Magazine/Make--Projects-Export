{"device":"Programming","url":"http:\/\/makeprojects.com\/Project\/InterActive+3+%E2%80%94+Serial+EEPROMs\/3027\/1","guide":{"author":{"text":"Steven Robert Cypherd","userid":3592},"categories":["Programming"],"conclusion":"","difficulty":"Moderate","documents":[],"flags":[{"title":"User-Contributed Project","flagid":"GUIDE_USER_CONTRIBUTED","text":"This project guide is not managed by MAKE staff."}],"guideid":3027,"image":{"imageid":56364,"text":"http:\/\/guide-images.makeprojects.org\/igi\/nKoWNCTYI6EaRr1T"},"introduction":"<p>I updated my program with full insert and delete. No networking or display. No plus formatting. Just a good E-Prom editor. Make sure you have strings before using insert or delete. It takes time to run insert and delete. I read and then write each string to its new place. My program does not check for limits on anything. The address is very important. If your address is off by a few bytes then you will lose those bytes from the front or back of your string. No errors happen. This 16 * tmp5 \u2013 1 looks OK. It is not OK. Basic Stamps are strictly left to right math. Basic Stamps 2s allow parentheses as 16 * (tmp5 \u2013 1). With this 16 * tmp5 \u2013 1 is actually (16 * tmp5) \u2013 1 and you would be off by 1 address. In this case I lost the first letter of the string I was editing.<\/p>\n\n<p>Math can be fun. The Basic Stamp 2s support negative numbers, but you must be careful with them. If you have two variables counting down and you are comparing them tmp3 &gt;= tmp4. If tmp3 reaches 0 and you subtract 1 it will be negative and more than tmp4. Put a debug statement on tmp3 and see where it goes. In this case my target is tmp5. I changed it to tmp4 &gt;= tmp5 and let tmp3 go to 0. Then I adjusted tmp5 by \u2013 1 for the 0 based array of strings. Zeros are not good for math or comparing.<\/p>\n\n<p>The main thing you need for an interactive device is memory. The cheapest and easiest memory to use is a serial EEPROM. What is an EEPROM? It is an electrically programmable and electrically erasable memory with a serial interface. EEPROMs keep their memory contents when the power is shut off. EEPROMs let you re-program the memory, usually for ten million or so cycles. Consult the data sheet for your EEPROM for the exact specifications. You can store just about any type of data into an EEPROM. I wish I had friends to share this with. I will be working on LCD displays and kind of a dumb terminal to show how easy it is to connect your ideas to your people.<\/p>\n\n<p>The program code zip is up on <a href=\"http:\/\/instructables.com\" rel=\"nofollow\">Instructables<\/a> and <a href=\"http:\/\/letsmakerobots.com\" rel=\"nofollow\">Let's Make Robots<\/a>.<\/p>\n\n<p>Most EEPROMs are byte-sized memory arrays. The biggest users of memory are strings like the quintessential \u201cHello World\u201d. Strings are an array of bytes in the processor\u2019s memory. Strings are well suited to EEPROMs. In this example my serial EEPROM is 2048\/8 or 16K with 128 16-byte pages. Yes, 128 strings. Like most serial devices EEPROMs have a processor that is set up to write and read the memory array. You control them with commands and input and output leads. Timing is everything.<\/p>\n\n<p>You need a lot of pins to use a serial EEPROM when you are writing to the memory. The pins: SO (Serial Output), SI (Serial Input), CK (Clock) and CS (Chip Select). I use separate pins for SO &amp; SI to protect my EEPROM. You use commands to tell the EEPROM what you want it to do. To read a byte you lower CS and send in a Read command, such as <tt>ShiftOut epRead\\8, erAddr\\16<\/tt>. The \\8 tells ShiftOut to send 8 bits total. So 32 is 100000 in binary notation, which is only 6 bits. The \\8 makes it 00100000 and that is 8 bits. That is what the EEPROM needs. Reading is a continuous stream of bytes as long as you provide clock pulses. <tt>ShiftIn myStr(tmp1)<\/tt>. You can use an address with the read command. Each page is 16 Bytes. So 32 is page 1. Remember the EEPROM memory is zero-based and strings are zero-terminated.<\/p>\n\n<p>Writing is a bit more complicated. You hold Write Protect and Hold pins high, then you set CS low and send a Write Enable command, such as <tt>SHIFTOUT epSi, epCk, MSBFIRST, [epWrtEN\\8]<\/tt>. Then you raise CS, pause 5ms, lower CS and pause 5ms again. That enters the command into the EEPROM. Then you send in a Write command. <tt>SHIFTOUT epWrite\\8, erAddr\\16<\/tt>. When writing you usually need to write all 16 bytes in one command and terminate it correctly. In a loop I will use something like <tt>SHIFTOUT myStr(tmp1)<\/tt>. Then I pause 5ms and raise my CS to tell the EEPROM to write my data. You must wait or the EEPROM may crash. To reset the EEPROM you lower CS, wait 5ms, then raise CS, wait 5ms then lower CS and continue with your commands. I keep my CS line low with a 10K resistor to ground.<\/p>\n\n<p>The EEPROM also has a Write Protect pin. With this pin low you cannot write to the EEPROM. It also has a Hold pin; when it is low the EEPROM is off. You can write-protect one quarter, half or all of the memory with status flags. I keep Write Protect and Hold connected to V<sub>DD<\/sub>.<\/p>\n\n<p>Addressing is mandatory and easy. I use addresses on 16 Byte boundaries so it is easy. You can write any 16-byte page of memory that you need to and nothing else is affected. Truly random access memory on 128 16-byte strings. Remember the memory is zero-based and strings are zero-terminated. String 1 is actually string 0. All of my string numbering is one-based. My program takes care of the details. In my program <tt>epAddr<\/tt> is the string edit point and <tt>myStrS<\/tt> is how many strings I have. Displaying the strings starts at 0 and runs though <tt>myStrS<\/tt> numbering each string. With concatenated strings only the first string gets a number. Likewise, with sub-strings only the first one gets a number.<\/p>\n\n<p>One thing about string handling is that most systems use zero-terminated strings. That means that the last byte in \u201cHello World0\u201d is a zero byte. A 16 Byte array holds 15 characters and a terminating zero. Also most byte arrays are zero-based. That is, the first position is zero and the last is 15. For stings to be recognized you have to make sure that the zero is in the right place. You can use just one 16-byte array for everything. For short strings just move them to the front and terminate them. The rest of the string will be ignored. Keep track of your position. When you are concatenating a string to the next string you cannot use all 16 bytes. Why? The output routine still needs the first string terminated.<\/p>\n\n<p>Other data needs to be formatted to fit into a <tt>byte<\/tt> array. A <tt>word<\/tt> has 16 bits or two bytes: a high byte and a low byte. <tt>Long<\/tt>s or <tt>double<\/tt>s have 32 bits or four bytes: byte 3, byte 2, byte 1 and byte 0. You build formatters to take care of this type of data. Store them byte by byte in an order you like, like high byte then low byte. Load them back the same way. The memory of most processors is 16 bit pages. Word-sized memory that can be broken down into Bytes and on some down to the nybbles or bits for variables. When you store a <tt>word<\/tt> variable you usually have access to its bytes as variables too.<\/p>\n\n<p>Some processors have good string handling functions. I am using a Parallax Basic Stamp 2 for this example. The commands used are Debug, DebugIn, SerIn and SerOut. Debug and serOut are the same function in most respects they just go to different places. To input a string you use a STR formatter that looks for character strings. <tt>DebugIn STR time\\15\\13<\/tt> looks for and inputs a string up to 15 characters long that it loads into a byte array when the user presses Enter (13). If the string is less than 15 characters then the remaining characters are filled with zeros. The string \u201cHello\u201d would be \u201cHello000000000<wbr \/>00\u201d in memory. <tt>Debug STR time<\/tt> prints \u201cHello\u201d. The first zero terminates the string and the rest are ignored.<\/p>\n\n<p>Numbers can be fun. The input formatters are for character strings. <tt>DebugIn DEC time<\/tt> looks at the string \u201chello123bye\u201d and converts it to the number 123 and puts it into the variable <tt>time<\/tt>. It ignores the rest. It is useful for a lot of interactive things. For byte arrays you use control characters like zero as a terminator at the end of strings. You create other control characters to fit your needs. I use the \u2018+\u2019 to separate short strings and join long strings in my output routines. Short strings can be put together usually in the front of the EEPROM. Fifteen characters are never enough. You can create all sorts of controls in output routines.<\/p>\n\n<p>My program: The button enters command mode. Enter a command and press Enter on the keyboard. You cannot keep these small processors waiting for an input. They are prone to crashing. You run an active loop waiting for a button to be pressed. My program stores the last address and the string count into the processor\u2019s EEPROM and loads it at start up or re-boot. Set <tt>myStrs<\/tt> to zero for new strings and 1 for your strings to be loaded. My program is a fast string loader for an EEPROM.<\/p>\n\n<p>My program uses the debug terminal and a standard button. You push the button to enter command mode. Type your input and press Enter. The LED should flash when waiting for a command. Remember to set the processor's EEPROM when you end a session.<\/p>","introduction_rendered":"<p>I updated my program with full insert and delete. No networking or display. No plus formatting. Just a good E-Prom editor. Make sure you have strings before using insert or delete. It takes time to run insert and delete. I read and then write each string to its new place. My program does not check for limits on anything. The address is very important. If your address is off by a few bytes then you will lose those bytes from the front or back of your string. No errors happen. This 16 * tmp5 \u2013 1 looks OK. It is not OK. Basic Stamps are strictly left to right math. Basic Stamps 2s allow parentheses as 16 * (tmp5 \u2013 1). With this 16 * tmp5 \u2013 1 is actually (16 * tmp5) \u2013 1 and you would be off by 1 address. In this case I lost the first letter of the string I was editing.<\/p>\n\n<p>Math can be fun. The Basic Stamp 2s support negative numbers, but you must be careful with them. If you have two variables counting down and you are comparing them tmp3 &gt;= tmp4. If tmp3 reaches 0 and you subtract 1 it will be negative and more than tmp4. Put a debug statement on tmp3 and see where it goes. In this case my target is tmp5. I changed it to tmp4 &gt;= tmp5 and let tmp3 go to 0. Then I adjusted tmp5 by \u2013 1 for the 0 based array of strings. Zeros are not good for math or comparing.<\/p>\n\n<p>The main thing you need for an interactive device is memory. The cheapest and easiest memory to use is a serial EEPROM. What is an EEPROM? It is an electrically programmable and electrically erasable memory with a serial interface. EEPROMs keep their memory contents when the power is shut off. EEPROMs let you re-program the memory, usually for ten million or so cycles. Consult the data sheet for your EEPROM for the exact specifications. You can store just about any type of data into an EEPROM. I wish I had friends to share this with. I will be working on LCD displays and kind of a dumb terminal to show how easy it is to connect your ideas to your people.<\/p>\n\n<p>The program code zip is up on <a href=\"http:\/\/instructables.com\" rel=\"nofollow\">Instructables<\/a> and <a href=\"http:\/\/letsmakerobots.com\" rel=\"nofollow\">Let's Make Robots<\/a>.<\/p>\n\n<p>Most EEPROMs are byte-sized memory arrays. The biggest users of memory are strings like the quintessential \u201cHello World\u201d. Strings are an array of bytes in the processor\u2019s memory. Strings are well suited to EEPROMs. In this example my serial EEPROM is 2048\/8 or 16K with 128 16-byte pages. Yes, 128 strings. Like most serial devices EEPROMs have a processor that is set up to write and read the memory array. You control them with commands and input and output leads. Timing is everything.<\/p>\n\n<p>You need a lot of pins to use a serial EEPROM when you are writing to the memory. The pins: SO (Serial Output), SI (Serial Input), CK (Clock) and CS (Chip Select). I use separate pins for SO &amp; SI to protect my EEPROM. You use commands to tell the EEPROM what you want it to do. To read a byte you lower CS and send in a Read command, such as <tt>ShiftOut epRead\\8, erAddr\\16<\/tt>. The \\8 tells ShiftOut to send 8 bits total. So 32 is 100000 in binary notation, which is only 6 bits. The \\8 makes it 00100000 and that is 8 bits. That is what the EEPROM needs. Reading is a continuous stream of bytes as long as you provide clock pulses. <tt>ShiftIn myStr(tmp1)<\/tt>. You can use an address with the read command. Each page is 16 Bytes. So 32 is page 1. Remember the EEPROM memory is zero-based and strings are zero-terminated.<\/p>\n\n<p>Writing is a bit more complicated. You hold Write Protect and Hold pins high, then you set CS low and send a Write Enable command, such as <tt>SHIFTOUT epSi, epCk, MSBFIRST, [epWrtEN\\8]<\/tt>. Then you raise CS, pause 5ms, lower CS and pause 5ms again. That enters the command into the EEPROM. Then you send in a Write command. <tt>SHIFTOUT epWrite\\8, erAddr\\16<\/tt>. When writing you usually need to write all 16 bytes in one command and terminate it correctly. In a loop I will use something like <tt>SHIFTOUT myStr(tmp1)<\/tt>. Then I pause 5ms and raise my CS to tell the EEPROM to write my data. You must wait or the EEPROM may crash. To reset the EEPROM you lower CS, wait 5ms, then raise CS, wait 5ms then lower CS and continue with your commands. I keep my CS line low with a 10K resistor to ground.<\/p>\n\n<p>The EEPROM also has a Write Protect pin. With this pin low you cannot write to the EEPROM. It also has a Hold pin; when it is low the EEPROM is off. You can write-protect one quarter, half or all of the memory with status flags. I keep Write Protect and Hold connected to V<sub>DD<\/sub>.<\/p>\n\n<p>Addressing is mandatory and easy. I use addresses on 16 Byte boundaries so it is easy. You can write any 16-byte page of memory that you need to and nothing else is affected. Truly random access memory on 128 16-byte strings. Remember the memory is zero-based and strings are zero-terminated. String 1 is actually string 0. All of my string numbering is one-based. My program takes care of the details. In my program <tt>epAddr<\/tt> is the string edit point and <tt>myStrS<\/tt> is how many strings I have. Displaying the strings starts at 0 and runs though <tt>myStrS<\/tt> numbering each string. With concatenated strings only the first string gets a number. Likewise, with sub-strings only the first one gets a number.<\/p>\n\n<p>One thing about string handling is that most systems use zero-terminated strings. That means that the last byte in \u201cHello World0\u201d is a zero byte. A 16 Byte array holds 15 characters and a terminating zero. Also most byte arrays are zero-based. That is, the first position is zero and the last is 15. For stings to be recognized you have to make sure that the zero is in the right place. You can use just one 16-byte array for everything. For short strings just move them to the front and terminate them. The rest of the string will be ignored. Keep track of your position. When you are concatenating a string to the next string you cannot use all 16 bytes. Why? The output routine still needs the first string terminated.<\/p>\n\n<p>Other data needs to be formatted to fit into a <tt>byte<\/tt> array. A <tt>word<\/tt> has 16 bits or two bytes: a high byte and a low byte. <tt>Long<\/tt>s or <tt>double<\/tt>s have 32 bits or four bytes: byte 3, byte 2, byte 1 and byte 0. You build formatters to take care of this type of data. Store them byte by byte in an order you like, like high byte then low byte. Load them back the same way. The memory of most processors is 16 bit pages. Word-sized memory that can be broken down into Bytes and on some down to the nybbles or bits for variables. When you store a <tt>word<\/tt> variable you usually have access to its bytes as variables too.<\/p>\n\n<p>Some processors have good string handling functions. I am using a Parallax Basic Stamp 2 for this example. The commands used are Debug, DebugIn, SerIn and SerOut. Debug and serOut are the same function in most respects they just go to different places. To input a string you use a STR formatter that looks for character strings. <tt>DebugIn STR time\\15\\13<\/tt> looks for and inputs a string up to 15 characters long that it loads into a byte array when the user presses Enter (13). If the string is less than 15 characters then the remaining characters are filled with zeros. The string \u201cHello\u201d would be \u201cHello000000000<wbr \/>00\u201d in memory. <tt>Debug STR time<\/tt> prints \u201cHello\u201d. The first zero terminates the string and the rest are ignored.<\/p>\n\n<p>Numbers can be fun. The input formatters are for character strings. <tt>DebugIn DEC time<\/tt> looks at the string \u201chello123bye\u201d and converts it to the number 123 and puts it into the variable <tt>time<\/tt>. It ignores the rest. It is useful for a lot of interactive things. For byte arrays you use control characters like zero as a terminator at the end of strings. You create other control characters to fit your needs. I use the \u2018+\u2019 to separate short strings and join long strings in my output routines. Short strings can be put together usually in the front of the EEPROM. Fifteen characters are never enough. You can create all sorts of controls in output routines.<\/p>\n\n<p>My program: The button enters command mode. Enter a command and press Enter on the keyboard. You cannot keep these small processors waiting for an input. They are prone to crashing. You run an active loop waiting for a button to be pressed. My program stores the last address and the string count into the processor\u2019s EEPROM and loads it at start up or re-boot. Set <tt>myStrs<\/tt> to zero for new strings and 1 for your strings to be loaded. My program is a fast string loader for an EEPROM.<\/p>\n\n<p>My program uses the debug terminal and a standard button. You push the button to enter command mode. Type your input and press Enter. The LED should flash when waiting for a command. Remember to set the processor's EEPROM when you end a session.<\/p><div class=\"parts\"><strong>Relevant parts<\/strong><ul><li><a href=\"http:\/\/make.dozuki.com\/Item\/Basic_Stamp_2\">Basic Stamp 2<\/a><\/li><\/ul><\/div>","locale":"en","parts":[{"text":"Basic Stamp 2","notes":"","url":"http:\/\/make.dozuki.com\/Item\/Basic_Stamp_2","thumbnail":""}],"prereqs":[],"steps":[{"title":"","lines":[{"text":"E-Proms","text_raw":"E-Proms","bullet":"black","level":0},{"text":"My Program","text_raw":"My Program","bullet":"black","level":0}],"object":null,"images":[{"imageid":55278,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/OVu1nLgN3yOFJWwM"},{"imageid":55280,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/AYVLeBxiWhKVbC4k"},{"imageid":56357,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/uihVKShKmqWVGIUf"}],"number":1},{"title":"","lines":[{"text":"Button - Light","text_raw":"Button - Light","bullet":"black","level":0},{"text":"Code","text_raw":"Code","bullet":"black","level":0}],"object":null,"images":[{"imageid":56358,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/bQigp3pj2FCg5kqx"},{"imageid":56359,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/VHjsLVUT5LmK4egl"},{"imageid":56360,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/doNfWXZnsr1NeHsP"}],"number":2},{"title":"","lines":[{"text":"Code","text_raw":"Code","bullet":"black","level":0}],"object":null,"images":[{"imageid":56361,"orderby":1,"text":"http:\/\/guide-images.makeprojects.org\/igi\/pMFAtELttHFkQi2J"},{"imageid":56362,"orderby":2,"text":"http:\/\/guide-images.makeprojects.org\/igi\/kigiaVsDctK6VrXP"},{"imageid":56363,"orderby":3,"text":"http:\/\/guide-images.makeprojects.org\/igi\/qSJpJLasKXJQCeBX"}],"number":3}],"subject":"","summary":"The basics of using an EEPROM.","time_required":"2 hours","title":"InterActive 3 \u2014 Serial EEPROMs","tools":[],"type":"project"},"guideid":"3027"}